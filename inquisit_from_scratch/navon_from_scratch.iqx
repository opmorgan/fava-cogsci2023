// Workflow (https://www.rondotsch.nl/inquisit-tutorial/)
// Define stim
//    32 target-present
// 	  8  target-absent
// Define instructions and prompts
//	  General instructions
//	  response-specific instructions ("/")
//	  response-specific instructions ("z")
// Define trial types (what stim are presented? Which responses are valid/correct?)
//	  instructions (keys for next, previous)
//    practice target-present ("/")
//	  practice target-absent ("/")
//	  main target-present ("/")
//    main target-absent ("/")
//    practice target-present ("z")
//	  practice target-absent ("z")
//	  main target-present ("z")
//    main target-absent ("z")
// Define blocks, and instructions for each block
//	  General instructions
//	  response-specific instructions ("/")
//    practice block ("/") (12 t-p, 4 t-a)
//	  main block ("/") (32 t-p, 8 t-a, times 2) 
//	  response-specific instructions ("z")
//    practice block ("z") (12 t-p, 4 t-a)
//	  main block ("z") (32 t-p, 8 t-a, times 2)
// Experiment loop. Define order of blocks

**************************************************************************************************************
	Data recording
**************************************************************************************************************
<monkey>
/ latencydistribution = constant(250)
/ percentcorrect = 75
</monkey>

<data>
/ columns = (build, computer.platform, date, time, values.timestamp, values.time_elapsed_ms, 
subject, group, session, blockcode, blocknum, 
trialcode, trialnum, values.stimulus_left, values.stimulus_right, values.stim_index,
values.target_present, response, correct, latency)
// Consider coding practice/main as "phase", repsonse key as "response condition"
</data>


**************************************************************************************************************
	Config: parameters, defaults, expressions
**************************************************************************************************************

// User-specified variables // TODO: move to config
<parameters>
/ background_color = white
/ foreground_color = black
/ fontfamily_default = "Avenir Next"
/ fontsize_default = 5% // Change to 14pt?
/ fontsize_fixation = 10%
/ iti = 0 // Time between response and next fixation, or time after timeout with nonresponse
/ fixation_duration = 600
/ shape_duration = 134
/ blank_duration = 256
/ mask_duration = 134 // Experiment setting: 134. Changed to 2000ms for testing
/ timeout = 2600 // Maximum response time (stimulus onset + 2000)
/ feedback_duration = 500
/ stim_size = 40%
/ stim_xposition_left = 40%
/ stim_xposition_right = 60%
/ stim_yposition = 50%
</parameters>

<defaults>
/ fontstyle = (parameters.fontfamily_default, parameters.fontsize_default)
/ screencolor = parameters.background_color
// txcolor = parameters.foreground_color
/ txbgcolor = parameters.background_color
</defaults>

<expressions>
// Define event onset times using durations set in <parameters>
/ fixation_onset = 0
/ shape_onset = parameters.fixation_duration
/ blank_onset = parameters.fixation_duration + parameters.shape_duration
/ mask_onset = parameters.fixation_duration + parameters.shape_duration + parameters.blank_duration
/ iti_onset = parameters.fixation_duration + parameters.shape_duration + parameters.blank_duration + parameters.mask_duration
</expressions>


**************************************************************************************************************
	Initialize values
**************************************************************************************************************
<values>
/ trial_counter = 0 // used in trials to control stimulus selection
/ stim_index = 0 // used in trials to control stimulus selection
/ target_present = "" // used in trials to track whether target is present
/ stimulus = "" // used in trials to record which stimulus was presented
/ stimulus_left = "" // used in trials to record which stimulus was presented
/ stimulus_right = "" // used in trials to record which stimulus was presented
/ time_elapsed_ms = 0 // used to record experiment duration
/ timestamp = 0 // used to record time of events
</values>


**************************************************************************************************************
	Stimuli
**************************************************************************************************************
//// Load stimuli specified in load_stimuli.iqx:
// stim_practice_left; stim_practice_right;
// stim_main_left; stim_main_right
//  Practice:
//    12 target-present
//    4  target-absent
//  Main:
//    32 target-present
// 	  8  target-absent
<include>
/ file = "load_stimuli.iqx"
</include>

// Define stimulus selection pools
<list stim_selector_practice>
// Note: controls the selection of the 16 stimuli for the practice condition
// (item list contain the possible itemnumbers)
// The first 12 are target-present; the last 4 are target-absent.
/ items = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)
/ poolsize = 16
/ replace = false
/ resetinterval = 0 // Reset after all items have been selected -- number of items needs to match number presented per block
</list>

<list stim_selector_main>
// Note: controls the selection of the 16 stimuli for the practice condition
// (item list contain the possible itemnumbers)
// The first 32 are target-present; the last 8 are target-absent.
/ items = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40)
/ poolsize = 40
/ replace = false
/ resetinterval = 0 // Reset after all items have been selected -- number of items needs to match number presented per block
</list>

<text stim_fixation>
/ items = ("+")
/ fontstyle = (parameters.fontfamily_default, parameters.fontsize_fixation, false, false, false, false, 5, 1)
/ position = (50%, 50%)
</text>

<text prompt_interblock_break> // TODO: add timer
/items = ("Nice job! You are halfway there. in 20 seconds, the next block will begin.")
</text>


// Define instructions and prompts
//	  General instructions
//	  response-specific instructions ("/")
//	  response-specific instructions ("z")
//	  feedback for correct/incorrect practice trials
<page instructions_intro> // TODO: write, move to htmlpage
Instructions (intro)
</page>

<page instructions_practice_slash> // TODO: write, move to htmlpage
Practice round. When you see a square or circle, press "/"
</page>

<page instructions_practice_z> // TODO: write, move to htmlpage
Practice round. When you see a square or circle, press "z"
</page>

<text incorrect_message>
/ items = ("      INCORRECT      ")
/ txcolor = (255, 0, 0)
</text>

<text correct_message>
/ items = ("     CORRECT     ")
/ txcolor = (0, 255, 0)
</text>

<page instructions_main_slash> // TODO: write, move to htmlpage
Get ready for the real experiment! When you see a square or circle, press "/"
</page>

<page instructions_main_z> // TODO: write, move to htmlpage
Get ready for the real experiment! When you see a square or circle, press "z"
</page>

<page instructions_end> // TODO: write, move to htmlpage
Instructions (intro)
</page>

// Define trial types (what stim are presented? Which responses are valid/correct?)
//	  instructions (keys for next, previous)
//    practice  ("/") 12 target-present, 4 target-absent [16 trials total]
//	  main      ("/") 32 target-present, 8 target-absent [40 trials total]
//    practice  ("z") 12 target-present, 4 target-absent [16 trials total]
//	  main      ("z") 32 target-present, 8 target-absent [40 trials total]
<instruct>
/ nextkey = ("n")
/ prevkey = ("p")
</instruct>

<trial practice_slash>
/ ontrialbegin = [
	values.trial_counter += 1;
	values.stim_index = list.stim_selector_practice.nextvalue;
	if (values.stim_index <= 12){ // Trials 1-12: present
		values.target_present = "yes";
	} else if (values.stim_index > 12) { //Trials 13-16: absent
		values.target_present = "no";
	} else {
		values.target_present = "error: stimulus index out of bounds";
	};
	trial.practice_slash.insertstimulustime(clearscreen, expressions.shape_onset); // 600ms: refresh screen
	trial.practice_slash.insertstimulustime(picture.stim_practice_left, expressions.shape_onset); // 600ms: show stimulus
	trial.practice_slash.insertstimulustime(picture.stim_practice_right, expressions.shape_onset); // 600ms: show stimulus

	
	trial.practice_slash.insertstimulustime(clearscreen, expressions.blank_onset); // 600+134ms: show blank
	
	trial.practice_slash.insertstimulustime(picture.stim_mask_left, expressions.mask_onset); // 600+134ms+256ms: show mask
	trial.practice_slash.insertstimulustime(picture.stim_mask_right, expressions.mask_onset); // 600+134ms+256ms: show mask

    trial.practice_slash.insertstimulustime(clearscreen, expressions.iti_onset); // 600+134ms+256ms: show blank (iti)
]

/ stimulustimes = [0 = stim_fixation]
/ beginresponsetime = parameters.fixation_duration
/ responseinterrupt = immediate
/ timeout = parameters.timeout

/ validresponse = ("/", noresponse)
/ iscorrectresponse = [(values.stim_index <= 12 && trial.practice_slash.responsetext == "/") || (values.stim_index > 12 && trial.practice_slash.responsetext != "/")] 

/ ontrialend = [
	trial.practice_slash.resetstimulusframes();
	values.stimulus_left = picture.stim_practice_left.currentitem;
	values.stimulus_right = picture.stim_practice_right.currentitem;
	values.time_elapsed_ms = script.elapsedtime;
	values.timestamp = script.currenttime;
]

/ posttrialpause = parameters.iti
/ recorddata = true
</trial>

<trial practice_z>
/ ontrialbegin = [
	values.trial_counter += 1;
	values.stim_index = list.stim_selector_practice.nextvalue;
	if (values.stim_index <= 12){ // Trials 1-12: present
		values.target_present = "yes";
	} else if (values.stim_index > 12) { //Trials 13-16: absent
		values.target_present = "no";
	} else {
		values.target_present = "error: stimulus index out of bounds";
	};
	trial.practice_z.insertstimulustime(clearscreen, expressions.shape_onset); // 600ms: refresh screen
	trial.practice_z.insertstimulustime(picture.stim_practice_left, expressions.shape_onset); // 600ms: show stimulus
	trial.practice_z.insertstimulustime(picture.stim_practice_right, expressions.shape_onset); // 600ms: show stimulus

	
	trial.practice_z.insertstimulustime(clearscreen, expressions.blank_onset); // 600+134ms: show blank
	
	trial.practice_z.insertstimulustime(picture.stim_mask_left, expressions.mask_onset); // 600+134ms+256ms: show mask
	trial.practice_z.insertstimulustime(picture.stim_mask_right, expressions.mask_onset); // 600+134ms+256ms: show mask
    trial.practice_z.insertstimulustime(clearscreen, expressions.iti_onset); // 600+134ms+256ms: show blank (iti)
]

/ stimulustimes = [0 = stim_fixation]
/ beginresponsetime = parameters.fixation_duration
/ responseinterrupt = immediate
/ timeout = parameters.timeout

/ validresponse = ("z", noresponse)
/ iscorrectresponse = [(values.stim_index <= 12 && trial.practice_z.responsetext == "z") || (values.stim_index > 12 && trial.practice_z.responsetext != "z")] 

/ ontrialend = [
	trial.practice_z.resetstimulusframes();
	values.stimulus = picture.stim_practice_left.currentitem;
	values.stimulus = picture.stim_practice_right.currentitem;
	values.time_elapsed_ms = script.elapsedtime;
    values.timestamp = script.currenttime;
]

/ posttrialpause = parameters.iti
/ recorddata = true
</trial>

<trial main_slash>
/ ontrialbegin = [
	values.trial_counter += 1;
	values.stim_index = list.stim_selector_main.nextvalue;
	if (values.stim_index <= 32){ // Trials 1-32: present
		values.target_present = "yes";
	} else if (values.stim_index > 32) { //Trials 33-40: absent
		values.target_present = "no";
	} else {
		values.target_present = "error: stimulus index out of bounds";
	};
	trial.main_slash.insertstimulustime(clearscreen, expressions.shape_onset); // 600ms: refresh screen
	trial.main_slash.insertstimulustime(picture.stim_main_left, expressions.shape_onset); // 600ms: show stimulus
	trial.main_slash.insertstimulustime(picture.stim_main_right, expressions.shape_onset); // 600ms: show stimulus
	
	trial.main_slash.insertstimulustime(clearscreen, expressions.blank_onset); // 600+134ms: show blank
	
	trial.main_slash.insertstimulustime(picture.stim_mask_left, expressions.mask_onset); // 600+134ms+256ms: show mask
	trial.main_slash.insertstimulustime(picture.stim_mask_right, expressions.mask_onset); // 600+134ms+256ms: show mask

    trial.main_slash.insertstimulustime(clearscreen, expressions.iti_onset); // 600+134ms+256ms: show blank (iti)
]

/ stimulustimes = [0 = stim_fixation]
/ beginresponsetime = parameters.fixation_duration
/ responseinterrupt = immediate
/ timeout = parameters.timeout

/ validresponse = ("/", noresponse)
/ iscorrectresponse = [(values.stim_index <= 32 && trial.main_slash.responsetext == "/") || (values.stim_index > 32 && trial.main_slash.responsetext != "/")] 
// Hack: set correct response for absent trials to responsetext != "/"
/ ontrialend = [
	trial.main_slash.resetstimulusframes();
	values.stimulus_left = picture.stim_main_left.currentitem;
	values.stimulus_right = picture.stim_main_right.currentitem;
	values.time_elapsed_ms = script.elapsedtime;
	values.timestamp = script.currenttime;
]

/ posttrialpause = parameters.iti
/ recorddata = true
</trial>

<trial main_z>
/ ontrialbegin = [
	values.trial_counter += 1;
	values.stim_index = list.stim_selector_main.nextvalue;
	if (values.stim_index <= 32){ // Trials 1-32: present
		values.target_present = "yes";
	} else if (values.stim_index > 32) { //Trials 33-40: absent
		values.target_present = "no";
	} else {
		values.target_present = "error: stimulus index out of bounds";
	};
	trial.main_z.insertstimulustime(clearscreen, expressions.shape_onset); // 600ms: refresh screen
	trial.main_z.insertstimulustime(picture.stim_main_left, expressions.shape_onset); // 600ms: show stimulus
	trial.main_z.insertstimulustime(picture.stim_main_right, expressions.shape_onset); // 600ms: show stimulus
	
	trial.main_z.insertstimulustime(clearscreen, expressions.blank_onset); // 600+134ms: show blank
	
	trial.main_z.insertstimulustime(picture.stim_mask_left, expressions.mask_onset); // 600+134ms+256ms: show mask
	trial.main_z.insertstimulustime(picture.stim_mask_right, expressions.mask_onset); // 600+134ms+256ms: show mask

    trial.main_z.insertstimulustime(clearscreen, expressions.iti_onset); // 600+134ms+256ms: show blank (iti)
]

/ stimulustimes = [0 = stim_fixation]
/ beginresponsetime = parameters.fixation_duration
/ responseinterrupt = immediate
/ timeout = parameters.timeout

/ validresponse = ("/", noresponse)
/ iscorrectresponse = [(values.stim_index <= 32 && trial.main_z.responsetext == "/") || (values.stim_index > 32 && trial.main_z.responsetext != "z")] 

/ ontrialend = [
	trial.main_z.resetstimulusframes();
	values.stimulus_left = picture.stim_main_left.currentitem;
	values.stimulus_right = picture.stim_main_right.currentitem;
	values.time_elapsed_ms = script.elapsedtime;
	values.timestamp = script.currenttime;
]
</trial>

<trial interblock_break>
/ stimulusframes = [1 = prompt_interblock_break]
/ trialduration = 20000 // TODO: MOVE TO CONFIG (parameters.interblock_break_duration)
</trial>

// Define blocks
//    practice block ("/") 12 target-present, 4 target-absent          [16 trials total]
//	  main block     ("/") 32 target-present, 8 target-absent, times 2 [80 trials total]
//    practice block ("z") 12 target-present, 4 target-absent          [16 trials total]
//	  main block     ("z") 32 target-present, 8 target-absent, times 2 [80 trials total]
<block practice_slash>
/ trials = [
	// How to present 12 present, 4 absent?
	// (a) Select without replacement on list of 12 present; list of 4 absent (does this work?)
	// 1-16 = noreplace(practice_present_slash, practice_absent_slash) // Make sure this randomly selects from full pool; if not, move logic.
	// (b) Predefine set of 16 stim, in one trial type. Randomly present those 16.
	1-16 = noreplace(practice_slash)
    // It might be harder to handle responses in (b).
	]
/ preinstructions = (instructions_practice_slash)
/ errormessage = (incorrect_message, parameters.feedback_duration)
/ correctmessage = (correct_message, parameters.feedback_duration)
</block>

<block practice_z>
/ trials = [
	1-16 = noreplace(practice_z)
	]
/ preinstructions = (instructions_practice_z)
/ errormessage = (incorrect_message, parameters.feedback_duration)
/ correctmessage = (correct_message, parameters.feedback_duration)
</block>

<block main_slash>
/ trials = [
	// How to present 32 present, 8 absent?
	// (a) Select without replacement on list of 32 present; list of 8 absent (does this work?)
	// 1-40 = noreplace(main_present_slash, main_absent_slash);
	// 41-80 = noreplace(main_present_slash, main_absent_slash) 
	// (b) Predefine set of 40 stim, in one trial type. Randomly present those 40.
	// It might be harder to handle responses in (b).
	 1-40 = noreplace(main_slash);
	41-80 = noreplace(main_slash);
	]
/ preinstructions = (instructions_main_slash)
</block>

<block main_z>
/ trials = [
	 1-40 = noreplace(main_slash);
	41-80 = noreplace(main_slash);
	]
/ preinstructions = (instructions_main_z)
</block>

<block interblock_break>
/ trials = [1=interblock_break]
</block>

// Define experiment
// Order:
//	  General instructions
//	  response-specific instructions ("/")
//    practice block ("/") (12 t-p, 4 t-a)
//	  main block ("/") (32 t-p, 8 t-a, times 2) 
//	  response-specific instructions ("z")
//    practice block ("z") (12 t-p, 4 t-a)
//	  main block ("z") (32 t-p, 8 t-a, times 2)
// For 1/2 subjects, do "z" blocks first.
<expt>
/ subjects = (1 of 2) // Subjects who will respond with "/" first
// To automatically assign subject ID and group by odd/even, host on inquisit website.
// https://www.millisecond.com/support/docs/current/html/articles/websubjectnumbers.htm
/ preinstructions = (instructions_intro)
/ postinstructions = (instructions_end)
/ blocks = [
	1=practice_slash;
	2=main_slash;
	3=interblock_break;
	4=practice_z;
	5=main_z;
	]
</expt>

<expt>
/ subjects = (2 of 2) // Subjects who will respond with "z" first
/ preinstructions = (instructions_intro)
/ postinstructions = (instructions_end)
/ blocks = [
	1=practice_z;
	2=main_z;
	3=interblock_break;
	4=practice_slash;
	5=main_slash;
	]
</expt>


